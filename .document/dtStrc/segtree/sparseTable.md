# Sparse Table
スパーステーブルは区間に対する演算が冪等性を持つときに前計算 $O(N \lg N)$，クエリ毎に $O(1)$ で答えられるデータ構造．  
冪等性を持つ演算というのは，操作の結果が常に同じことを意味する．  
今回の場合は，
$L_1\le L_2,\ R_1\le R_2$を満たす区間
$[L_1,R_1),\ [L_2,R_2)$
の共通部分が空集合でないとき$(L_2< R_1)$に
$op([L_1,R_1),[L_2,R_2))=op([L_1,R_2))$
を満たすことである．

例えば，和演算やXOR演算は操作を複数回繰り返すと当然ながら結果が異なるため冪等性がない演算である．  
逆に冪等性がある演算は min, max, bitwise-and/or など．

## コンストラクタ
```C++
template<class S,S(*op)(S,S),S(*e)()>
sparseTable<>();                 // empty
sparseTable<>(vector<S>&&);      // move
sparseTable<>(const vector<S>&); // copy
```
この時点では構築しない．  
copy では $O(N)$.  
moveとデフォルトコンストラクタでは $O(1)$.

`S`は演算を定義する型．  
$op:S^2\rightarrow S$ となる写像(関数).  
$e:S$ は演算の単位元．  
単位元は`resize`を用いるときに必要になる．  
|演算|単位元|
|-|-|
|max|`S`の最小値, INT32_MINなど|
|min|`S`の最大値, INT32_MAXなど|
|bitwise-and|全bitが $1$ |
|bitwise-or|全bitが $0$ |

## 区間積 $O(1)$
```C++
S prod(size_t l,size_t r);
```
$[L,R)$ の区間における演算結果を求める．  
この演算を初期化または更新の後に呼び出す場合 $O(N\lg N)$の前計算を行う．

前計算によって取りうる最大の $2$ 冪の値の長さの区間積をすべての位置から計算する．  
前計算の配列の具体的な長さを求める計算式は考えるのが面倒だったので実行時に配列にぶち込めるだけぶち込む方針を取りました．  

## 一点更新 $O(1)$
```C++
void set(size_t idx,const S&v);
```
場所 $idx$ に $v$ を代入する．  
配列サイズを超過する場合は，自動的にぴったりのサイズに合わせる．  
この時に限り，最悪計算量が $O(idx)$.

## サイズ更新 $O(N)$
```C++
void resize(size_t n);
```
サイズを伸ばすときは $O(N)$.  
縮めるときは $O(1)$.  
サイズを伸ばすと，新しい区間は単位元 $e$ で初期化される．