# modint
テンプレートで法となる $M$ を渡す `mint` と，`set_mod()` で法となる $M$ を `modint32` がある．  
提供するインタフェースは基本的に同じだが，動的な法の決定のみが`mint`と`modint32`の違いとなる．  
注意されたい点として，法が素数で無いときの`inv()`は必ずしも正しいとは限らない．また正しくないことを知らせる仕組みは存在しない．  

演算子は冗長なため明記しないが，同じ型の `mint`, `modint32` 同士と整数との四則演算と等価判定のみが可能．  
注意点として，同じ法を持っていても `modint32` のテンプレートの `id` が異なると比較は不可能．  
`istream`, `ostream`にはオーバーロードしているため，`cout<<x.val()<<endl;`のような記述は不要で`cout<<x<<endl;`とそのままいける．

`modint32` は内部的にbarretの償却アルゴリズムを用いるため，少しだけナイーブな除算より高速だが，`set_mod()`を呼ぶ回数除算が実行されるため，`set_mod()`の利用には注意が必要．競プロではほぼ考慮する必要のない注意点．

## mint (静的)
### コンストラクタ
```C++
mint<M>();
mint<M>(mint n);
mint<M>(integral n);
```
デフォルトコンストラクタでは， $0$ で初期化される．  
`integral` は任意の整数型を入れることができる．

### 整数値 $O(1)$
```C++
uint32_t val()const;
```
整数値を得る．
### 繰り返し二乗法 $O(\lg n)$
```C++
uint32_t pow(uint64_t n)const;
```
小数冪はできないので注意．

$\sqrt{x}$ とか言われても知らないもんね～～～．

### 逆元 $O(\lg x)$
```C++
uint32_t inv()const;
```
拡張ユークリッドの互除法なので $O(\lg x)$．  
maspyさん曰く，[前処理 $O(M^{2/3})$ で $O(1)$ の逆元計算](https://maspypy.com/o1-mod-inv-mod-pow)ができるらしいよ．知らんけど．

### 法 $O(1)$
```C++
friend uint32_t mod()const;
```
法となる $M$ を返す．使うときは `mint::mod();`という風に使う．

## modint (動的)
### set_mod()
```C++
void modint<id>::set_mod(uint32_t);
```
