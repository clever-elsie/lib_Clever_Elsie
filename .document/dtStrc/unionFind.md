# unionFind
コンストラクタで頂点数を渡し、 $[0,n)$ で管理する。  
計算量は`same, unite, root`に関してアッカーマン関数の逆関数を $\alpha$ として、
本来償却計算時間で $O(\alpha(N))$ になる.  
ところで競プロではクエリの数が少ないため $O(\lg N)$ 程度であると考えてもよい(はず)。

## コンストラクタ $O(n)$
```C++
unionFind();
unionFind(int32_t n);
```
頂点数を $n$ として構築．

## 代表元(根) $O(\alpha(n))$
```C++
int32_t root(int32_t u)
```
頂点 $u$ の所属する素集合の代表元を返す．  
計算量は償却で $O(\alpha(n))$．
$\alpha$ はアッカーマン関数の逆関数．

償却の計算量は，計算量が期待値周辺に密集しない場合などにすべての計算量の総和を試行回数で割って均したものと考えると簡単．  
したがって $1$ 回あたりの最悪計算量は $O(\alpha(n))$ではない．

具体的には $O(\lg n)$ だがそのようなケースは極めて少ない．  
$1$ 回当たりの最悪計算量が $O(\lg n)$ になることは union by size を行うためである．  
union by size によって $2$ つの木を繋げる場合，必ずサイズが小さいほうの木が子となる．
このような木の高さが平均的に $\lg n$ になりそうなことは，同じサイズの木を結合することを繰り返す操作を手元で行うと直感的に理解できる．
期のサイズに偏りがあったとしても，それは大きいサイズの木の対数で押さえられるためそこまで問題は無い．

ある頂点に対して`root()`を呼び出すと，
その頂点から根までに存在するすべての頂点は根に隣接し，
その頂点を親としてみている頂点も圧縮された経路分根に近づくため，
`root()`の均し計算量は $O(\lg n)$より小さいことは直感的には明らかである．

## 部分木の位数 $O(\alpha(n))$
```C++
int32_t size(int32_t u);
```
頂点 $u$ の所属する素集合に含まれる調点数を求める．  
内部的に`root`を呼ぶため計算量は $O(\alpha(n))$.

## 同一素集合に含まれるか $O(\alpha(n))$
```C++
bool same(int32_t u,int32_t v);
```
頂点 $u,v$ が同じ素集合に含まれるかどうか判定する．  
内部的に `root` を呼び出すため計算量は $O(\alpha(n))$.

## 素集合の結合 $O(\alpha(n))$
```C++
void unite(int32_t u,int32_t v);
```
頂点 $u,v$ を同じ素集合にまとめる．  
内部的に `root` を呼び出すため計算量は $O(\alpha(n))$.

## グラフの位数(頂点数) $O(1)$
```C++
int32_t ord();
```
構築時に渡した $n$ を返す．


# unionFindP (ポテンシャル付き unionFind)
特に記述が無い限り，`unionFind`と同じ．
## コンストラクタ
```C++
template<class S> unionFindP<S>();
template<class S> unionFindP<S>(int32_t n);
```
ポテンシャルの型 `S` を与えることのみが`unionFind`と異なる．

## 結合
```C++
bool unite(int32_t u,int32_t v,S w)
```
ポテンシャルを $p$ として， $p_u=p_v+w$ という情報を与える．
既知の情報を矛盾しないとき `true` を返し結合する．  
矛盾が存在すれば結合せずに `false`を返す．

## ポテンシャル O(\alpha(n))
```C++
S potential(int32_t u)
```
頂点 $u$ の根からのポテンシャルを返す．

## 相対差分 O(\alpha(n))
```C++
S diff(int32_t u,int32_t v);
```
`u`が`v`よりどれだけ高いかという情報を返す．  
同一素集合に属しているときのみ正しい値を返す．


# dsu (可換モノイド付きunionFind)
dsuはdisjoint set unionなので，本来は可換モノイドが載っていることを示す言葉ではない．
dsuという名前が空いていたため使っているだけなので，dsuが可換モノイド付きであるという理解をしてはならない．
つまり`unionFindwithMonoid`と書くのがめんどくさかっただけである．

特に記載がない場合は`unionFind`と同じである．`unionFind`を継承しているため．

## コンストラクタ
```C++
template<class S,S(*op)(S,S),S(*e)()>
dsu(),dsu(int32_t n);
```
集合`S`，演算`op`，単位元`e`を与える必要がある．
演算は必ず可換である必要がある．
これはunion by sizeを行うためである．

## 代入
```C++
void set(int32_t u,const S&v);
```
頂点 $u$ の集合に値 $v$ を代入する．  

## 積
```C++
S prod(int32_t u);
```
頂点 $u$ の集合における演算結果を得る．